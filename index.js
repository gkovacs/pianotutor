// Generated by CoffeeScript 1.6.3
(function() {
  var STRING_INSERTED, STRING_INVERSIONFIRST, STRING_INVERSIONSECOND, STRING_MATCH, STRING_MISSED, STRING_SPACE, STRING_SUBSTITUTION, alphabet, blast_text, corpus_lines, d_rows, getSubstitutionScore, make_key_mapping, matchLength, nextLine, q_rows, removeNonAlpha, removeWhitespace, root, showLine, substitution_table, to_dvorak, transformTypedChar, updateText;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.targetText = 'hi guys where are you all going';

  STRING_MATCH = 1;

  STRING_SUBSTITUTION = 2;

  STRING_MISSED = 3;

  STRING_INSERTED = 4;

  STRING_SPACE = 5;

  STRING_INVERSIONFIRST = 7;

  STRING_INVERSIONSECOND = 8;

  alphabet = 'abcdefghijklmnopqrstuvwxyz';

  root.stringToIndex = {};

  (function() {
    var idx, letter, _i, _len, _results;
    _results = [];
    for (idx = _i = 0, _len = alphabet.length; _i < _len; idx = ++_i) {
      letter = alphabet[idx];
      _results.push(root.stringToIndex[letter] = idx);
    }
    return _results;
  })();

  getSubstitutionScore = function(letterA, letterB) {
    var indexA, indexB;
    indexA = root.stringToIndex[letterA.toLowerCase()];
    indexB = root.stringToIndex[letterB.toLowerCase()];
    return root.substitutionMatrix[indexA][indexB];
  };

  blast_text = function(typedText, referenceText) {
    var i, j, maxscore, maxscore_i, maxscore_j, op, operationTypes, output, prevReferenceChar, prevTypedChar, referenceChar, scores, substitutionScore, typedChar, x, y, _i, _j, _k, _ref, _ref1, _ref2;
    scores = [];
    operationTypes = [];
    for (i = _i = 0, _ref = typedText.length + 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      scores[i] = (function() {
        var _j, _ref1, _results;
        _results = [];
        for (j = _j = 0, _ref1 = referenceText.length + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(-1000);
        }
        return _results;
      })();
      operationTypes[i] = (function() {
        var _j, _ref1, _results;
        _results = [];
        for (j = _j = 0, _ref1 = referenceText.length + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(0);
        }
        return _results;
      })();
    }
    scores[0][0] = 0;
    maxscore = 0;
    maxscore_i = 0;
    maxscore_j = 0;
    for (i = _j = 0, _ref1 = typedText.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      typedChar = typedText[i];
      for (j = _k = 0, _ref2 = referenceText.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
        referenceChar = referenceText[j];
        if (referenceChar === ' ') {
          scores[i + 1][j + 1] = scores[i + 1][j];
          operationTypes[i + 1][j + 1] = STRING_SPACE;
        } else if (typedChar === referenceChar) {
          scores[i + 1][j + 1] = scores[i][j] + 1;
          operationTypes[i + 1][j + 1] = STRING_MATCH;
        } else {
          substitutionScore = getSubstitutionScore(referenceChar, typedChar) - .1;
          scores[i + 1][j + 1] = scores[i][j] + substitutionScore;
          operationTypes[i + 1][j + 1] = STRING_SUBSTITUTION;
          if (i > 0 && j > 0 && operationTypes[i][j] === STRING_SUBSTITUTION) {
            prevTypedChar = typedText[i - 1];
            prevReferenceChar = referenceText[j - 1];
            if (typedChar === prevReferenceChar && referenceChar === prevTypedChar) {
              scores[i + 1][j + 1] += .8;
              operationTypes[i + 1][j + 1] = STRING_INVERSIONSECOND;
              operationTypes[i][j] = STRING_INVERSIONFIRST;
            }
          }
          if (scores[i][j + 1] - .4 > scores[i + 1][j + 1]) {
            scores[i + 1][j + 1] = scores[i][j + 1] - .4;
            operationTypes[i + 1][j + 1] = STRING_INSERTED;
          }
          if (scores[i + 1][j] - .7 > scores[i + 1][j + 1]) {
            scores[i + 1][j + 1] = scores[i + 1][j] - .7;
            operationTypes[i + 1][j + 1] = STRING_MISSED;
          }
        }
        if (scores[i + 1][j + 1] > maxscore) {
          maxscore = scores[i + 1][j + 1];
          maxscore_i = i + 1;
          maxscore_j = j + 1;
        }
      }
    }
    console.log('maxscore_i: ' + maxscore_i);
    console.log('maxscore_j: ' + maxscore_j);
    console.log('maxscore: ' + maxscore);
    output = [];
    x = typedText.length;
    y = maxscore_j;
    while (x !== 0 && y !== 0) {
      op = operationTypes[x][y];
      if (op === STRING_MATCH || op === STRING_SUBSTITUTION || op === STRING_INVERSIONFIRST || op === STRING_INVERSIONSECOND) {
        x -= 1;
        y -= 1;
        output.push(typedText[x]);
      }
      if (op === STRING_MISSED) {
        y -= 1;
      }
      if (op === STRING_INSERTED) {
        x -= 1;
        output.push(typedText[x]);
      }
      if (op === STRING_SPACE) {
        y -= 1;
        output.push(' ');
      }
    }
    return [output.reverse().join(''), maxscore_j];
  };

  removeWhitespace = function(text) {
    var c, output, _i, _len;
    output = [];
    for (_i = 0, _len = text.length; _i < _len; _i++) {
      c = text[_i];
      output.push(c.trim());
    }
    return output.join('');
  };

  removeNonAlpha = function(text) {
    var c, output, _i, _len;
    output = [];
    for (_i = 0, _len = text.length; _i < _len; _i++) {
      c = text[_i];
      c = c.toLowerCase();
      if (alphabet.indexOf(c) !== -1) {
        output.push(c);
      }
    }
    return output.join('');
  };

  root.currentLineNum = 0;

  nextLine = function() {
    root.currentLineNum += 1;
    return showLine();
  };

  showLine = function() {
    window.location.hash = '#' + root.currentLineNum;
    console.log('showLine for line' + currentLineNum);
    root.targetText = root.corpus_lines[root.currentLineNum].toLowerCase();
    $('#textDisplay_entered').text('');
    return $('#textDisplay_todo').text(root.targetText);
  };

  root.formValueIncludesInputted = false;

  root.haveCheckedFormValueIncludesInputted = false;

  matchLength = function(str1, str2) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = Math.min(str1.length, str2.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (str1[i].toLowerCase() !== str2[i].toLowerCase()) {
        return i;
      }
    }
    return i;
  };

  root.currentLineStartTime = 0;

  root.lineFinishLogs = [];

  root.sendLogs = function() {
    var startTime;
    startTime = root.lineFinishLogs[0].startedAt;
    return $.get('/varTable?varname=' + escape(startTime) + '&set=' + escape(JSON.stringify(root.lineFinishLogs)), function(data) {
      $('#logLink').attr('href', '/varTable?varname=' + escape(startTime));
      return $('#logLink').show();
    });
  };

  root.wasDeletePressed = false;

  root.lastText = '';

  updateText = function() {
    var ntext, numMatched, reftext_entered, reftext_todo;
    ntext = $('#textInput').val();
    if (ntext === root.lastText) {
      return;
    }
    root.lastText = ntext;
    if (root.currentLineStartTime === 0 && ntext.trim().length > 0) {
      root.currentLineStartTime = new Date().getTime();
    }
    if (root.startTime === 0 && ntext.trim().length > 0) {
      root.startTime = new Date().getTime();
      $('#startTime').text(new Date(root.startTime).toString());
    }
    numMatched = matchLength(ntext.trim(), root.targetText);
    reftext_entered = root.targetText.slice(0, numMatched);
    reftext_todo = root.targetText.slice(numMatched);
    $('#textDisplay_entered').text(reftext_entered);
    $('#textDisplay_todo').text(reftext_todo);
    if (numMatched === root.targetText.length) {
      $('#textInput').val('');
      root.lineFinishLogs.push({
        'targetText': root.targetText,
        'startedAt': new Date(root.currentLineStartTime).toString(),
        'completedAt': new Date().toString()
      });
      root.currentLineStartTime = 0;
      if (root.targetText === 'you are now done typing') {
        root.sendLogs();
      }
      if (!root.wasDeletePressed) {
        return nextLine();
      } else {
        root.wasDeletePressed = false;
        return showLine();
      }
    }
  };

  root.hashname_to_index = {};

  corpus_lines = root.corpus_lines = root.corpus.split('\n');

  (function() {
    var hashidx, hashname, idx, line, _i, _ref, _results;
    _results = [];
    for (idx = _i = 0, _ref = corpus_lines.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
      line = corpus_lines[idx];
      hashidx = line.indexOf('#');
      if (hashidx !== -1) {
        hashname = line.slice(hashidx + 1).trim();
        root.hashname_to_index[hashname] = idx;
        _results.push(corpus_lines[idx] = line.slice(0, hashidx).trim());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  })();

  $(document).ready(function() {
    var hashstring, hashstringAsInt;
    if (window.location.hash != null) {
      hashstring = window.location.hash.split('#').join('');
      if (root.hashname_to_index[hashstring] != null) {
        root.currentLineNum = root.hashname_to_index[hashstring];
      } else {
        hashstringAsInt = parseInt(hashstring);
        if (!isNaN(hashstringAsInt)) {
          root.currentLineNum = hashstringAsInt;
        }
      }
    }
    showLine();
    $('#textInput').focus();
    $('#textInput').bind('propertychange keyup input paste', function(event) {
      updateText();
      return false;
    });
    return $("#textInput").bind('keydown', function(evt) {
      var end, origChar, start, transformedChar, val;
      if (evt.which != null) {
        console.log(evt.which);
        if (evt.which === 8) {
          root.wasDeletePressed = true;
        }
        origChar = root.mapKeyPressToActualCharacter(evt.shiftKey, evt.which);
        console.log(origChar);
        transformedChar = transformTypedChar(origChar);
        if (transformedChar !== origChar) {
          start = this.selectionStart;
          end = this.selectionEnd;
          val = this.value;
          this.value = val.slice(0, start) + transformedChar + val.slice(end);
          this.selectionStart = this.selectionEnd = start + 1;
          return false;
        }
      }
    });
  });

  make_key_mapping = function(qwerty_rows, dvorak_rows) {
    var dvorak_key, dvorak_row, i, j, output, qwerty_key, qwerty_row, _i, _j, _ref, _ref1;
    output = {};
    for (i = _i = 0, _ref = qwerty_rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      qwerty_row = qwerty_rows[i];
      dvorak_row = dvorak_rows[i];
      for (j = _j = 0, _ref1 = qwerty_row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        qwerty_key = qwerty_row[j];
        dvorak_key = dvorak_row[j];
        output[qwerty_key] = dvorak_key;
      }
    }
    console.log(output);
    return output;
  };

  q_rows = ['qwertyuiop[]', "asdfghjkl;'", 'zxcvbnm,./', 'QWERTYUIOP{}', 'ASDFGHJKL:"', 'ZXCVBNM<>?'];

  d_rows = ["',.pyfgcrl/=", 'aoeuidhtns-', ';qjkxbmwvz', '"<>PYFGCRL?+', 'AOEUIDHTNS_', ':QJKXBMWVZ'];

  to_dvorak = make_key_mapping(q_rows, d_rows);

  substitution_table = to_dvorak;

  transformTypedChar = function(origChar) {
    if (substitution_table[origChar] != null) {
      return substitution_table[origChar];
    }
    return origChar;
  };

}).call(this);
